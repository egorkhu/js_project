{"version":3,"sources":["Board.js","Food.js","Game.js","Main.js","Menu.js","Settings.js","Snake.js","Status.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../app.js","sourcesContent":["class Board {\n    constructor() {\n        this.boardEl = document.getElementById('game');\n        this.bla = 0;\n    }\n\n    /**\n     * Метод получает другие игровые объекты, которые нужны ему\n     * для работы.\n     * @param {Settings} settings объект настроек.\n     * @param {Snake} snake объект змейки.\n     */\n    init(settings, snake) {\n        this.settings = settings;\n        this.snake = snake;\n    }\n\n    /**\n     * Метод отрисовывает игровое поле.\n     */\n    renderBoard() {\n        this.boardEl.innerHTML = '';\n        for (let row = 0; row < this.settings.rowsCount; row++) {\n            let tr = document.createElement('tr');\n            this.boardEl.appendChild(tr);\n\n            for (let col = 0; col < this.settings.colsCount; col++) {\n                let td = document.createElement('td');\n                tr.appendChild(td);\n            }\n        }\n    }\n\n    /**\n     * Метод отрисовывает змейку на доске.\n     */\n    renderSnake() {\n        const snakeBodyElems = this.getSnakeBodyElems(this.snake.body);\n        if (snakeBodyElems) {\n            snakeBodyElems.forEach(function(tdEl) {\n                tdEl.classList.add('snakeBody');\n            })\n        }\n    }\n\n    /**\n     * Метод очищает игровое поле.\n     */\n    clearBoard() {\n        const tdElems = document.querySelectorAll('td');\n        tdElems.forEach(function(td) {\n            td.className = \"\";\n        });\n    }\n\n    /**\n     * Получаем ячейку таблицы.\n     * @param {number} x координата по оси х.\n     * @param {number} y координата по оси y.\n     * @returns {HTMLTableCellElement} тег td\n     */\n    getCellEl(x, y) {\n        return this.boardEl.querySelector(`tr:nth-child(${y}) td:nth-child(${x})`);\n    }\n\n    /**\n     * Получаем набор тегов td, представляющих тело змейки.\n     * @param {array} bodyCoords массив объектов с координатами\n     * @returns {HTMLTableCellElement[]|null} возвращается набор тегов td если были\n     * переданы координаты, иначе null.\n     */\n    getSnakeBodyElems(bodyCoords) {\n        if (bodyCoords.length > 0) {\n            let bodyElems = [];\n            for (let value of bodyCoords) {\n                let elem = this.getCellEl(value.x, value.y);\n                bodyElems.push(elem);\n            }\n            return bodyElems;\n        }\n        return null;\n    }\n\n    /**\n     * Является ли следующий шаг, шагом в стену.\n     * @param {Object} nextCellCoords - координаты ячейки, куда змейка собирается сделать шаг.\n     * @param {number} nextCellCoords.x\n     * @param {number} nextCellCoords.y\n     * @returns {boolean}\n     */\n    isNextStepToWall(nextCellCoords) {\n        let nextCell = this.getCellEl(nextCellCoords.x, nextCellCoords.y);\n        return nextCell === null;\n    }\n\n    /**\n     * Метод рисует еду на игровом поле.\n     * @param {Food} coords будущее расположение еды на поле\n     * @param {number} coords.x координата x\n     * @param {number} coords.y координата y\n     */\n    renderFood(coords) {\n        const foodCell = this.getCellEl(coords.x, coords.y);\n        foodCell.classList.add('food');\n    }\n\n    /**\n     * Метод проверяет съела ли змейка еду.\n     * @returns {boolean} true если змейка находится на еде, иначе false.\n     */\n    isHeadOnFood() {\n        return this.boardEl.querySelector('.food').classList.contains('snakeBody');\n    }\n\n    /**\n     * Метод проверяет врезались ли змейка сама в себя.\n     * @returns {boolean} true если голова змейки врезалась в тело\n     */\n    crossingSnakeBody() {\n        let headCoords = this.snake.body[0];\n        let cell = this.getCellEl(headCoords.x, headCoords.y);\n        if (cell.classList.contains('snakeBody')) {\n            return true;\n        }\n        return false;\n    }\n}","class Food {\n    constructor() {\n        this.x = null;\n        this.y = null;\n    }\n\n    /**\n     * Метод получает другие игровые объекты, которые нужны ему\n     * для работы.\n     * @param {Settings} settings объект настроек\n     * @param {Snake} snake объект змейки\n     * @param {Board} board объект игрового поля\n     */\n    init(settings, snake, board) {\n        this.settings = settings;\n        this.snake = snake;\n        this.board = board;\n    }\n\n    /**\n     * Метод устанавливает новое случайное положение еды на игровом\n     * поле.\n     */\n    setNewFood() {\n        const food = this.generateRandomCoordinates();\n        this.board.renderFood(food);\n    }\n\n    /**\n     * Метод устанавливает на игровом поле еду по текущим\n     * координатам.\n     */\n    setFood() {\n        this.board.renderFood(this);\n    }\n\n    /**\n     * Метод генерирует новый объект еды со случайным\n     * положением на игровом поле\n     * @returns {Food}\n     */\n    generateRandomCoordinates() {\n        while (true) {\n            this.x = Math.floor(Math.random() * this.settings.colsCount) + 1;\n            this.y = Math.floor(Math.random() * this.settings.rowsCount) + 1;\n            let cell = this.board.getCellEl(this.x, this.y);\n\n            if (cell.classList.contains('snakeBody')) {\n                continue;\n            }\n            return this;\n        }\n    }\n}","class Game {\n    constructor() {\n        this.tickIdentifier = null;\n        this.messageEl = document.getElementById('message');\n        this.scoreEl = document.getElementById('score');\n        this.method = this.pressKeyHandler.bind(this);\n    }\n\n    /**\n     * Метод получает другие игровые объекты, которые нужны ему\n     * для работы.\n     * @param {Settings} settings\n     * @param {Status} status\n     * @param {Board} board\n     * @param {Snake} snake\n     * @param {Menu} menu\n     * @param {Food} food\n     */\n    init(settings, status, board, snake, menu, food) {\n        this.settings = settings;\n        this.status = status;\n        this.board = board;\n        this.snake = snake;\n        this.menu = menu;\n        this.food = food;\n    }\n\n    /**\n     * Метод назначает обработчики на события клика на кнопки \"Старт\",\n     * \"Пауза\", а также на стрелки на клавиатуре.\n     */\n    run() {\n        this.setScore();\n        this.showScore();\n        this.menu.addButtonsClickListeners(this.start.bind(this), this.pause.bind(this), this.again.bind(this), this.menu.allBtnsClearFocus);\n        document.addEventListener('keydown', this.method);\n    }\n\n    /**\n     * Метод запускает игру.\n     */\n    start() {\n        if (this.status.isPaused()) {\n            this.status.setPlaying();\n            this.tickIdentifier = setInterval(this.doTick.bind(this), 1000 / this.settings.speed);\n        }\n    }\n\n    /**\n     * Метод ставит игру на паузу.\n     */\n    pause() {\n        if (this.status.isPlaying()) {\n            this.status.setPaused();\n            clearInterval(this.tickIdentifier);\n        }\n    }\n\n    /**\n     * Метод начинает игру сначала.\n     */\n    again() {\n        this.pause();\n        this.board.clearBoard();\n        this.food.setNewFood();\n        this.snake.resetSnake();\n        this.board.renderSnake();\n        document.addEventListener('keydown', this.method);\n        this.setScore();\n        this.setMessage('');\n    }\n\n    /**\n     * Этот метод запускается каждую секунду и осуществляет:\n     * 1. перемещение змейки\n     * 2. проверяет проиграна/выиграна ли игра\n     * 3. увеличивает размер змейки если она ест еду\n     * 4. заново отрисовывает положение змейки и еды\n     */\n    doTick() {\n        this.snake.performStep();\n        if (this.board.isNextStepToWall(this.snake.body[0])) {\n            this.passThroughWall(this.snake.body[0]);\n        }\n        if (this.isGameLost()) {\n            return;\n        }\n        if (this.isGameWon()) {\n            return;\n        }\n        if (this.board.isHeadOnFood()) {\n            this.snake.increaseBody();\n            this.setScore();\n            this.showScore();\n            this.food.setNewFood();\n        }\n        this.board.clearBoard();\n        this.food.setFood();\n        this.board.renderSnake();\n    }\n\n    /**\n     * Метод проверяет выиграна ли игра, останавливает игру,\n     * выводит сообщение о выигрыше.\n     * @returns {boolean} если длина змейки достигла длины нужной\n     * для выигрыша, тогда true, иначе false.\n     */\n    isGameWon() {\n        if (this.snake.body.length - 1 == this.settings.winLength) {\n            clearInterval(this.tickIdentifier);\n            this.setMessage('Вы выиграли');\n            document.removeEventListener('keydown', this.method);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Метод проверяет проиграна ли игра, останавливает игру\n     * в случае проигрыша, выводит сообщение о проигрыше.\n     * @returns {boolean} если мы шагнули в стену, тогда\n     * true, иначе false.\n     */\n    isGameLost() {\n        if (this.board.crossingSnakeBody()) {\n            clearInterval(this.tickIdentifier);\n            this.setMessage('Вы проиграли');\n            document.removeEventListener('keydown', this.method);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * В зависимости от нажатой кнопки (вверх, вниз, влево, вправо) будет\n     * вызываться соответствующий метод.\n     * @param {KeyboardEvent} event\n     */\n    pressKeyHandler(event) {\n        switch (event.key) {\n            case \"ArrowUp\":\n                this.snake.changeDirection('up');\n                break;\n            case \"ArrowDown\":\n                this.snake.changeDirection('down');\n                break;\n            case \"ArrowLeft\":\n                this.snake.changeDirection('left');\n                break;\n            case \"ArrowRight\":\n                this.snake.changeDirection('right');\n                break;\n            case \" \":\n                if (this.status.isPlaying()) {\n                    this.status.setPaused();\n                    clearInterval(this.tickIdentifier);\n                    break;\n                }\n                if (this.status.isPaused()) {\n                    this.status.setPlaying();\n                    this.tickIdentifier = setInterval(this.doTick.bind(this), 1000 / this.settings.speed);\n                    break;\n                }\n        }\n    }\n\n    /**\n     * Метод выводит сообщение на странице.\n     * @param {string} text\n     */\n    setMessage(text) {\n        this.messageEl.innerText = text;\n    }\n\n    /**\n     * Метод устанавливает счет игры.\n     */\n    setScore() {\n        this.score = this.snake.body.length - 1;\n    }\n\n    /**\n     * Метод показывает счет игры.\n     */\n    showScore() {\n        this.scoreEl.innerText = this.score;\n    }\n\n    /**\n     * Метод позволяет змейке проходить сквозь стены.\n     */\n    passThroughWall(headCoords) {\n        if (headCoords.x > this.settings.colsCount) {\n            headCoords.x = 1;\n        }\n        if (headCoords.y > this.settings.rowsCount) {\n            headCoords.y = 1;\n        }\n        if (headCoords.x < 1) {\n            headCoords.x = this.settings.colsCount;\n        }\n        if (headCoords.y < 1) {\n            headCoords.y = this.settings.colsCount;\n        }\n    }\n}","window.addEventListener('load', () => {\n    const settings = new Settings();\n    const status = new Status();\n    const snake = new Snake();\n    const board = new Board();\n    const menu = new Menu();\n    const food = new Food();\n    const game = new Game();\n\n    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n        settings.init({ rowsCount: 10, colsCount: 10, speed: 5, winLength: 5 });\n    } else {\n        settings.init({ speed: 5, winLength: 10 });\n    }\n    board.init(settings, snake);\n    food.init(settings, snake, board);\n    game.init(settings, status, board, snake, menu, food);\n\n    board.renderBoard();\n    board.renderSnake();\n\n    food.setNewFood();\n    game.run();\n});","class Menu {\n    constructor() {\n        this.startBtnEl = document.getElementById('startBtn');\n        this.pauseBtnEl = document.getElementById('pauseBtn');\n        this.againBtnEl = document.getElementById('againBtn');\n        this.btnsEls = document.querySelectorAll('button');\n    }\n\n    /**\n     * Метод назначает переданные функции в качестве обработчиков\n     * событий клика на кнопки \"Старт\", \"Пауза\" и \"Сначала\".\n     * @param {Function} startBtnClickHandler\n     * @param {Function} pauseBtnClickHandler\n     * @param {Function} againBtnClickHandler\n     * @param {Function} allBtnsClickHandlers\n     */\n    addButtonsClickListeners(startBtnClickHandler, pauseBtnClickHandler, againBtnClickHandler, allBtnsClickHandlers) {\n        this.startBtnEl.addEventListener('click', startBtnClickHandler);\n        this.pauseBtnEl.addEventListener('click', pauseBtnClickHandler);\n        this.againBtnEl.addEventListener('click', againBtnClickHandler);\n        for (let button of this.btnsEls) {\n            button.addEventListener('click', allBtnsClickHandlers);\n        }\n    }\n\n    /**\n     * Метод убирает фокус с кнопок после их нажатия.\n     */\n    allBtnsClearFocus() {\n        event.target.blur();\n    }\n}","class Settings {\n    /**\n     * @param {Object} params - Парметры игры.\n     * @param {number} params.rowsCount - количество строк игрового поля.\n     * @param {number} params.colsCount - количество колонок игрового поля.\n     * @param {number} params.speed - скорость перемещения змейки.\n     * @param {number} params.winLength - какую длину надо наесть, чтобы выиграть.\n     * @throws {Error} если переданы не верные настройки выбрасывается\n     * соответствующая ошибка.\n     */\n    init(params) {\n        let defaultParams = {rowsCount: 21, colsCount: 21, speed: 2, winLength: 5};\n        Object.assign(defaultParams, params);\n\n        if (defaultParams.rowsCount < 10 || defaultParams.rowsCount > 30) {\n            throw new Error('Неверные настройки, значение rowsCount должно быть в диапазоне [10, 30].');\n        }\n        this.rowsCount = defaultParams.rowsCount;\n\n        if (defaultParams.colsCount < 10 || defaultParams.colsCount > 30) {\n            throw new Error('Неверные настройки, значение rowsCount должно быть в диапазоне [10, 30].');\n        }\n        this.colsCount = defaultParams.colsCount;\n\n        if (defaultParams.speed < 1 || defaultParams.speed > 10) {\n            throw new Error('Неверные настройки, значение speed должно быть в диапазоне [1, 10].');\n        }\n        this.speed = defaultParams.speed;\n\n        if (defaultParams.winLength < 5 || defaultParams.winLength > 50) {\n            throw new Error('Неверные настройки, значение winLength должно быть в диапазоне [5, 50].');\n        }\n        this.winLength = defaultParams.winLength;\n    }\n}","class Snake {\n    constructor() {\n        this.possibleDirections = ['down', 'up', 'left', 'right'];\n\n        this.body = [{\n            x: 1,\n            y: 1,\n        }];\n\n        this.direction = 'down';\n    }\n\n    /**\n     * Меняем направление движения.\n     * @param {string} newDirection направление может быть down, up, left, right.\n     * @throws {Error} при передаче не корректного направления выбрасывается ошибка.\n     */\n    changeDirection(newDirection) {\n        if (!this.possibleDirections.includes(newDirection)) {\n            throw new Error('Передано не верное направление. Вы передали: ' + newDirection);\n        }\n        if (this.isPassedOppositeDirection(newDirection)) {\n            return;\n        }\n        this.direction = newDirection;\n    }\n\n    /**\n     * Метод проверяет, является ли переданное направление, противоположным\n     * тому куда сейчас движется змейка.\n     * @param {string} newDirection новое направление, может быть up, down, right, left.\n     * @returns {boolean} true если новое направление противоположно текущему,\n     * иначе false.\n     */\n    isPassedOppositeDirection(newDirection) {\n        if (this.direction == 'down' && newDirection == 'up') {\n            return true;\n        }\n        if (this.direction == 'up' && newDirection == 'down') {\n            return true;\n        }\n        if (this.direction == 'left' && newDirection == 'right') {\n            return true;\n        }\n        if (this.direction == 'right' && newDirection == 'left') {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Метод осуществляет шаг змейки. Добавляет ячейку перед существующим\n     * положением головы и удаляет одну ячейку в хвосте.\n     */\n    performStep() {\n        let currentHeadCoords = this.body[0];\n        let newHeadCoords = {\n            x: currentHeadCoords.x,\n            y: currentHeadCoords.y,\n        };\n        switch (this.direction) {\n            case \"down\":\n                newHeadCoords.y++;\n                break;\n            case \"up\":\n                newHeadCoords.y--;\n                break;\n            case \"left\":\n                newHeadCoords.x--;\n                break;\n            case \"right\":\n                newHeadCoords.x++;\n                break;\n        }\n        this.body.unshift(newHeadCoords);\n        this.body.pop();\n    }\n\n    /**\n     * Метод дублирует в массиве объектов представляющих тело змейки\n     * последнюю ячейку, т.е. в массиве в конце оказываются два\n     * одинаковых объекта. Когда метод performStep в самом конце\n     * удаляет последний элемент массива, он удаляет сдублированный\n     * объект, таким образом тело змейки растет.\n     */\n    increaseBody() {\n        let bodyLastCell = this.body[this.body.length - 1];\n        let newBodyLastCell = {\n            x: bodyLastCell.x,\n            y: bodyLastCell.y,\n        };\n        this.body.push(newBodyLastCell);\n    }\n\n    resetSnake() {\n        this.body = [{\n            x: 1,\n            y: 1,\n        }];\n\n        this.direction = 'down';\n    }\n}","/** Здесь будет хранится статус игры, например играем мы, завершили или остановлено. */\nclass Status {\n    constructor() {\n        this.setPaused();\n    }\n\n    /** Это значит что мы играем. */\n    setPlaying() {\n        this.condition = 'playing';\n    }\n\n    /** Это значит что игра на паузе. */\n    setPaused() {\n        this.condition = 'paused';\n    }\n\n    /**\n     * @returns {boolean} если мы сейчас играем, тогда true, иначе false.\n     */\n    isPlaying() {\n        return this.condition === 'playing';\n    }\n\n    /**\n     * @returns {boolean} если сейчас игра на паузе, тогда true, иначе false.\n     */\n    isPaused() {\n        return this.condition === 'paused';\n    }\n}"]}